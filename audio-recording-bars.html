<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Realtime Transcription UI Playground</title>
  <link rel="icon" href="data:,">
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    /* Simple drag handle cursor */
    .drag-handle { cursor: grab; }
    .drag-handle:active { cursor: grabbing; }

    /* Thin scrollbar for transcript pane */
    .thin-scroll::-webkit-scrollbar { height: 6px; width: 6px; }
    .thin-scroll::-webkit-scrollbar-thumb { background:#cbd5e1; border-radius: 6px; }
  </style>
</head>
<body class="bg-slate-50 text-slate-900">
  <div class="max-w-6xl mx-auto p-4 md:p-8">
    <header class="mb-4">
      <h1 class="text-2xl md:text-3xl font-semibold tracking-tight">Realtime Transcription UI Playground</h1>
      <p class="text-slate-600">Segmented progress (e.g., <span id="stepLabel">0/0</span>), editable segments, and a live audio level meter. Works with an audio file or the microphone.</p>
    </header>

    <!-- Controls -->
    <section class="grid md:grid-cols-3 gap-4 mb-6">
      <div class="bg-white rounded-2xl shadow p-4">
        <h2 class="font-medium mb-2">Audio Source</h2>
        <div class="flex items-center gap-2 mb-3">
          <input id="fileInput" type="file" accept="audio/*" class="block text-sm" />
        </div>
        <div class="flex items-center gap-2">
          <button id="micBtn" class="px-3 py-2 rounded-xl bg-slate-900 text-white text-sm">Use Microphone</button>
          <span id="sourceLabel" class="text-xs text-slate-500">No source</span>
        </div>
      </div>

      <div class="bg-white rounded-2xl shadow p-4">
        <h2 class="font-medium mb-2">Transport</h2>
        <div class="flex items-center gap-2 mb-3">
          <button id="playBtn" class="px-3 py-2 rounded-xl bg-emerald-600 text-white text-sm disabled:opacity-40" disabled>Play</button>
          <button id="pauseBtn" class="px-3 py-2 rounded-xl bg-amber-600 text-white text-sm disabled:opacity-40" disabled>Pause</button>
          <button id="stopBtn" class="px-3 py-2 rounded-xl bg-rose-600 text-white text-sm disabled:opacity-40" disabled>Stop</button>
          <span class="mx-2 text-slate-300">|</span>
          <button id="recStartBtn" class="px-3 py-2 rounded-xl bg-indigo-600 text-white text-sm">Start Recording</button>
          <button id="recStopBtn" class="px-3 py-2 rounded-xl bg-indigo-200 text-indigo-900 text-sm disabled:opacity-40" disabled>Stop & Render</button>
        </div>
        <div class="flex items-center justify-between">
          <div class="text-sm font-mono"><span id="curTime">00:00.0</span> / <span id="durTime">00:00.0</span></div>
          <div id="livePill" class="hidden text-xs px-2 py-1 rounded-lg bg-rose-100 text-rose-700 font-medium">LIVE</div>
        </div>
      </div>

      <div class="bg-white rounded-2xl shadow p-4">
        <h2 class="font-medium mb-2">Level Meter</h2>
        <canvas id="meter" width="420" height="36" class="w-full rounded-xl bg-slate-100"></canvas>
        <div class="text-xs text-slate-500 mt-1">Shows recent RMS level from file playback or mic input.</div>
      </div>
    </section>

    <!-- Segmented progress bar -->
    <section class="bg-white rounded-2xl shadow p-4 mb-6">
      <div class="flex items-center justify-between mb-3">
        <h2 class="font-medium">Segments <span class="text-slate-400 text-sm">(<span id="segCount">0</span> total)</span></h2>
        <div class="flex gap-2">
          <button id="addSegBtn" class="px-3 py-2 rounded-xl bg-slate-900 text-white text-sm">Add @ Current</button>
          <button id="splitSegBtn" class="px-3 py-2 rounded-xl bg-slate-700 text-white text-sm">Split Current</button>
          <button id="equalizeBtn" class="px-3 py-2 rounded-xl bg-slate-200 text-slate-900 text-sm">Equalize ×6</button>
        </div>
      </div>

      <div class="flex items-center gap-3 mb-3">
        <div class="text-sm text-slate-600">Step: <span id="stepLabel2" class="font-medium">0/0</span></div>
        <div class="text-xs text-slate-400">Draft vs Final visualization on bar</div>
      </div>

      <!-- Timeline wrapper -->
      <div class="relative w-full select-none">
        <div id="segBar" class="thin-scroll overflow-x-auto w-full border border-slate-200 rounded-2xl p-1 flex gap-1 items-stretch bg-slate-50"></div>
        <!-- playhead -->
        <div class="relative">
          <div id="playhead" class="absolute top-[-46px] w-0.5 bg-rose-600" style="height: 42px; left:0"></div>
        </div>
      </div>

      <div class="mt-3 text-xs text-slate-500">Tip: Click a segment to seek. Drag handles to reorder. Double‑click a segment to toggle Draft/Final.</div>
    </section>

    <!-- Waveform (static bars after recording or file decode) -->
    <section class="bg-white rounded-2xl shadow p-4 mb-6">
      <div class="flex items-center justify-between mb-2">
        <h2 class="font-medium">Waveform Bars</h2>
        <div class="text-xs text-slate-500">Click to seek • Renders after file load or when you stop recording</div>
      </div>
      <canvas id="waveform" height="140" class="w-full rounded-2xl bg-slate-100"></canvas>
    </section>

    <footer class="mt-6 text-xs text-slate-400">No backend required. Everything runs locally in your browser.</footer>
  </div>

  <audio id="player" controls class="w-full mt-4" crossorigin="anonymous"></audio>

  <script>
// Compact, brace-checked script. Provides: load file/record, draw waveform bars, segments, and play/pause.
(() => {
  'use strict';
  // Ensure Segment Editor tbody exists *before* we grab element refs
  (function ensureSegTable(){
    if (!document.getElementById('segTable')){
      const section = document.createElement('section');
      section.className = 'bg-white rounded-2xl shadow p-4';
      section.innerHTML = `<h2 class="font-medium mb-3">Segment Editor</h2>
        <div class="overflow-x-auto"><table class="min-w-full text-sm">
        <thead><tr class="text-left text-slate-500">
          <th class="py-2 pr-4">#</th><th class="py-2 pr-4">Title</th>
          <th class="py-2 pr-4">Start (s)</th><th class="py-2 pr-4">End (s)</th>
          <th class="py-2 pr-4">State</th><th class="py-2 pr-4">Actions</th>
        </tr></thead><tbody id="segTable"></tbody></table></div>`;
      document.querySelector('.max-w-6xl')?.appendChild(section);
    }
  })();

  const $ = (id) => document.getElementById(id);
  const els = {
    fileInput: $('fileInput'), micBtn: $('micBtn'), sourceLabel: $('sourceLabel'),
    playBtn: $('playBtn'), pauseBtn: $('pauseBtn'), stopBtn: $('stopBtn'),
    recStartBtn: $('recStartBtn'), recStopBtn: $('recStopBtn'),
    curTime: $('curTime'), durTime: $('durTime'), livePill: $('livePill'),
    meter: $('meter'), segBar: $('segBar'), playhead: $('playhead'),
    segTable: $('segTable'), segCount: $('segCount'), stepLabel: $('stepLabel'), stepLabel2: $('stepLabel2'),
    addSegBtn: $('addSegBtn'), splitSegBtn: $('splitSegBtn'), equalizeBtn: $('equalizeBtn'),
    waveform: $('waveform'), audioEl: $('player')
  };
  // Guard: if any critical element is null, bail early with console help.
  // (silenced) element checks to keep console clean

  // --- State
  const state = {
    mode: 'none', segments: [], currentIndex: -1, duration: 0,
    audioCtx: null, analyser: null, dataArray: null, sourceNode: null, raf: null,
    micStream: null, liveClockStart: 0, mediaRecorder: null, recChunks: [],
    bars: [], barCount: 600
  };

  // --- Utils
  const clamp = (v,a,b)=>Math.max(a,Math.min(b,v));
  const now = ()=>performance.now();
  const fmt = (t)=>{const s=Math.max(0,t|0);const ms=Math.max(0,Math.round((t-(t|0))*10));const m=(s/60)|0;const r=(s%60).toString().padStart(2,'0');return `${m}:${r}.${ms}`;};

  function ensureAudioGraph(){
    if (!state.audioCtx){
      state.audioCtx = new (window.AudioContext||window.webkitAudioContext)();
      state.analyser = state.audioCtx.createAnalyser();
      state.analyser.fftSize = 2048;
      state.dataArray = new Uint8Array(state.analyser.fftSize);
    }
  }
  function connectSource(node){
    try { if (state.sourceNode) state.sourceNode.disconnect(); } catch {}
    node.connect(state.analyser);
    if (state.mode === 'file') state.analyser.connect(state.audioCtx.destination);
    state.sourceNode = node;
  }

  // --- Time helpers
  function currentTime(){ return state.mode==='file' ? (els.audioEl.currentTime||0) : state.mode==='mic' ? (now()-state.liveClockStart)/1000 : 0; }
  function setCurrentTime(t){ if (state.mode==='file') els.audioEl.currentTime = clamp(t,0,state.duration); }
  function updateDuration(d){ state.duration=d; els.durTime.textContent=fmt(d); if(!state.segments.length && d>0){ state.segments=[{id:crypto.randomUUID(),title:'Segment 1',start:0,end:d,final:false}]; renderAll(); } }

  // --- Rendering
  function recalcStepLabels(){
    const idx = state.currentIndex>=0?state.currentIndex+1:0, tot=state.segments.length;
    els.stepLabel.textContent = `${idx}/${tot}`; els.stepLabel2.textContent = `${idx}/${tot}`; els.segCount.textContent = `${tot}`;
  }
  function renderSegBar(){
    if (!els.segBar) return; els.segBar.innerHTML=''; const dur=Math.max(0.001,state.duration||1);
    state.segments.forEach((seg,i)=>{
      const box=document.createElement('div');
      box.className='relative flex-none rounded-xl h-10 min-w-[40px] ring-1 ring-slate-200';
      if (i===state.currentIndex) box.classList.add('ring-rose-500','ring-2');
      box.style.flexBasis=`${((seg.end-seg.start)/dur)*100}%`;
      box.style.background = seg.final ? '#10b981' : '#cbd5e1';
      const label=document.createElement('div'); label.className='absolute inset-0 flex items-center justify-center text-xs font-medium text-white select-none'; label.textContent=(i+1)+'. '+seg.title; box.appendChild(label);
      box.addEventListener('click',()=>setCurrentTime((seg.start+seg.end)/2));
      box.addEventListener('dblclick',()=>{ seg.final=!seg.final; renderAll(); });
      els.segBar.appendChild(box);
    });
  }
  function renderPlayhead(){ if(!els.playhead||!els.segBar) return; const x=clamp(currentTime()/(Math.max(0.001,state.duration||1)),0,1)*els.segBar.scrollWidth; els.playhead.style.left=`${x-els.segBar.scrollLeft}px`; }
  function renderTable(){
    if (!els.segTable) return; els.segTable.innerHTML='';
    state.segments.forEach((seg,i)=>{
      const tr=document.createElement('tr'); tr.className='border-t border-slate-100';
      tr.innerHTML=`<td class="py-2 pr-4 text-slate-500">${i+1}</td>
        <td class="py-2 pr-4"><input class="px-2 py-1 rounded-lg border border-slate-200 bg-slate-50" value="${seg.title}"></td>
        <td class="py-2 pr-4"><input type="number" step="0.1" class="w-24 px-2 py-1 rounded-lg border border-slate-200 bg-slate-50" value="${seg.start.toFixed(1)}"></td>
        <td class="py-2 pr-4"><input type="number" step="0.1" class="w-24 px-2 py-1 rounded-lg border border-slate-200 bg-slate-50" value="${seg.end.toFixed(1)}"></td>
        <td class="py-2 pr-4"><button class="px-2 py-1 rounded-lg text-xs ${seg.final?'bg-emerald-100 text-emerald-700':'bg-slate-100 text-slate-600'}">${seg.final?'Final':'Draft'}</button></td>
        <td class="py-2 pr-4"><button class="px-2 py-1 rounded-lg text-xs bg-rose-100 text-rose-700">Delete</button></td>`;
      const [titleIn,startIn,endIn,stateBtn,delBtn] = [tr.children[1].firstChild,tr.children[2].firstChild,tr.children[3].firstChild,tr.children[4].firstChild,tr.children[5].firstChild];
      titleIn.addEventListener('input',()=>{ seg.title=titleIn.value; renderSegBar(); });
      startIn.addEventListener('change',()=>{ const v=clamp(parseFloat(startIn.value)||0,0,state.duration); seg.start=Math.min(v,seg.end-0.05); normalizeSegments(); renderAll(); });
      endIn.addEventListener('change',()=>{ const v=clamp(parseFloat(endIn.value)||0,0,state.duration); seg.end=Math.max(v,seg.start+0.05); normalizeSegments(); renderAll(); });
      stateBtn.addEventListener('click',()=>{ seg.final=!seg.final; renderAll(); });
      delBtn.addEventListener('click',()=>{ state.segments.splice(i,1); normalizeSegments(true); renderAll(); });
      els.segTable.appendChild(tr);
    });
  }
  function renderAll(){ const ct=currentTime(); state.currentIndex=state.segments.findIndex(s=>ct>=s.start&&ct<s.end); els.curTime.textContent=fmt(ct); recalcStepLabels(); renderSegBar(); renderPlayhead(); renderTable(); drawWaveform(); }

  // --- Meter, loop
  function drawMeter(rms){ const ctx=els.meter.getContext('2d'); const w=els.meter.width, h=els.meter.height; ctx.clearRect(0,0,w,h); ctx.fillStyle='#e2e8f0'; ctx.fillRect(0,0,w,h); ctx.fillStyle='#0ea5e9'; ctx.fillRect(0,0,clamp(rms*w*4,0,w),h); }
  function loop(){ state.raf=requestAnimationFrame(loop); if(state.mode==='mic') updateDuration((now()-state.liveClockStart)/1000); state.analyser.getByteTimeDomainData(state.dataArray); let sum=0; for(let i=0;i<state.dataArray.length;i++){ const v=(state.dataArray[i]-128)/128; sum+=v*v; } drawMeter(Math.sqrt(sum/state.dataArray.length)); renderAll(); }

  // --- Waveform bars
  async function buildBarsFromBlob(blob){ ensureAudioGraph(); const buf=await blob.arrayBuffer(); const audioBuf=await state.audioCtx.decodeAudioData(buf); const data=audioBuf.getChannelData(0); const len=data.length; const N=state.barCount; const step=Math.max(1,Math.floor(len/N)); const bars=new Array(N).fill(0); let prev=0; for(let i=0;i<N;i++){ let peak=0; for(let j=i*step;j<Math.min((i+1)*step,len);j++){ const v=Math.abs(data[j]); if(v>peak) peak=v; } const sm=0.6*peak+0.4*prev; bars[i]=sm; prev=sm; } const maxv=Math.max(0.001,Math.max(...bars)); state.bars=bars.map(v=>v/maxv); drawWaveform(); }
  function roundRect(ctx,x,y,w,h,r){ ctx.beginPath(); ctx.moveTo(x+r,y); ctx.arcTo(x+w,y,x+w,y+h,r); ctx.arcTo(x+w,y+h,x,y+h,r); ctx.arcTo(x,y+h,x,y,r); ctx.arcTo(x,y,x+w,y,r); ctx.closePath(); }
  function drawWaveform(){ const c=els.waveform; if(!c) return; const ctx=c.getContext('2d'); const w=c.width=c.clientWidth, h=c.height; ctx.clearRect(0,0,w,h); ctx.fillStyle='#e2e8f0'; ctx.fillRect(0,0,w,h); const N=state.bars.length; if(!N) return; const gap=1, barW=Math.max(1,Math.floor((w-(N-1)*gap)/N)); const mid=h/2; const playedN=Math.floor((currentTime()/Math.max(0.001,state.duration||1))*N); for(let i=0;i<N;i++){ const x=i*(barW+gap); const amp=state.bars[i]; const hh=Math.max(2,amp*(h*0.9)/2); const y=mid-hh; ctx.fillStyle = i<=playedN ? '#0ea5e9' : '#94a3b8'; roundRect(ctx,x,y,barW,hh*2,Math.min(6,barW/2)); ctx.fill(); } if(state.segments.length&&state.duration>0){ for(const s of state.segments){ const sx=(s.start/state.duration)*w, ex=(s.end/state.duration)*w; ctx.fillStyle=s.final?'rgba(16,185,129,0.08)':'rgba(15,23,42,0.06)'; ctx.fillRect(sx,0,ex-sx,h); } } }

  // --- Segment ops
  function normalizeSegments(keep=false){ if(!state.segments.length) return; const total=Math.max(0.001,state.duration||1); state.segments.sort((a,b)=>a.start-b.start); if(!keep){ let t=0; for(const s of state.segments){ const len=clamp(s.end-s.start,0.05,total); s.start=t; s.end=clamp(t+len,0.05,total); t=s.end; } state.segments[state.segments.length-1].end=total; } else { const lens=state.segments.map(s=>Math.max(0.05,s.end-s.start)); const sum=lens.reduce((a,b)=>a+b,0); let t=0; for(let i=0;i<state.segments.length;i++){ const len=total*(lens[i]/sum); state.segments[i].start=t; state.segments[i].end=t+len; t+=len; } state.segments[state.segments.length-1].end=total; } }
  function addSegmentAtCurrent(){ if(state.duration<=0) return; const ct=currentTime(); if(!state.segments.length){ state.segments.push({id:crypto.randomUUID(),title:'Segment 1',start:0,end:state.duration,final:false}); renderAll(); return; } const len=Math.min(3,Math.max(0.5,state.duration*0.05)); state.segments.push({id:crypto.randomUUID(),title:`@ ${fmt(ct)}`,start:ct,end:Math.min(ct+len,state.duration),final:false}); normalizeSegments(true); renderAll(); }
  function splitCurrent(){ const ct=currentTime(); const i=state.segments.findIndex(s=>ct>=s.start&&ct<s.end); if(i<0) return; const s=state.segments[i]; if(ct<=s.start+0.2||ct>=s.end-0.2) return; state.segments.splice(i,1,{id:crypto.randomUUID(),title:s.title+' (A)',start:s.start,end:ct,final:s.final},{id:crypto.randomUUID(),title:s.title+' (B)',start:ct,end:s.end,final:s.final}); renderAll(); }
  function equalize(n=6){ if((state.duration||0)<=0) return; const step=(state.duration)/n; state.segments=[]; for(let i=0;i<n;i++){ state.segments.push({id:crypto.randomUUID(),title:`Part ${i+1}`,start:i*step,end:(i+1)*step,final:i<Math.floor(n/2)}); } renderAll(); }

  // --- File/Mic/Record
  async function useFile(file){ stopAll(); ensureAudioGraph(); const url=URL.createObjectURL(file); els.audioEl.src=url; await els.audioEl.load(); state.mode='file'; els.sourceLabel.textContent=`File: ${file.name}`; els.livePill.classList.add('hidden'); const srcNode=state.audioCtx.createMediaElementSource(els.audioEl); connectSource(srcNode); els.audioEl.onloadedmetadata = async ()=>{ updateDuration(els.audioEl.duration||0); await buildBarsFromBlob(file); renderAll(); try{ await els.audioEl.play(); if(!state.raf) loop(); }catch{} } }
  async function useMic(){ stopAll(); ensureAudioGraph(); try{ const stream=await navigator.mediaDevices.getUserMedia({audio:true}); state.micStream=stream; const src=state.audioCtx.createMediaStreamSource(stream); connectSource(src); state.mode='mic'; els.sourceLabel.textContent='Microphone (monitoring)'; els.livePill.classList.remove('hidden'); state.liveClockStart=now(); updateDuration(0); loop(); }catch{ alert('Microphone permission denied.'); } }
  function stopAll(){ cancelAnimationFrame(state.raf); state.raf=null; try{ els.audioEl.pause(); }catch{} if(state.micStream){ state.micStream.getTracks().forEach(t=>t.stop()); state.micStream=null; } if(state.mediaRecorder && state.mediaRecorder.state!=='inactive'){ try{ state.mediaRecorder.stop(); }catch{} } }

  // --- Events
  els.fileInput.addEventListener('change',(e)=>{ if(e.target.files&&e.target.files[0]) useFile(e.target.files[0]); });
  els.micBtn.addEventListener('click',useMic);
  els.playBtn.addEventListener('click',()=>{ if(state.mode==='file'){ els.audioEl.play().catch(()=>{}); if(!state.raf) loop(); } });
  els.pauseBtn.addEventListener('click',()=>{ if(state.mode==='file') els.audioEl.pause(); });
  els.stopBtn.addEventListener('click',()=>{ if(state.mode==='file'){ els.audioEl.pause(); els.audioEl.currentTime=0; } });
  els.addSegBtn.addEventListener('click',addSegmentAtCurrent);
  els.splitSegBtn.addEventListener('click',splitCurrent);
  els.equalizeBtn.addEventListener('click',()=>equalize(6));
  els.waveform.addEventListener('click',(e)=>{ if(!state.duration) return; const r=els.waveform.getBoundingClientRect(); const x=e.clientX-r.left; setCurrentTime(clamp(x/r.width,0,1)*state.duration); });
  els.audioEl.addEventListener('timeupdate',renderAll);
  els.audioEl.addEventListener('ended',renderAll);
  els.audioEl.addEventListener('loadedmetadata',()=>{ updateDuration(els.audioEl.duration||0); renderAll(); });
  window.addEventListener('keydown',(e)=>{ if(e.target.tagName==='INPUT') return; if(e.key==='ArrowRight') setCurrentTime(currentTime()+2); if(e.key==='ArrowLeft') setCurrentTime(currentTime()-2); });

  // --- Recording (Start/Stop & render bars)
  els.recStartBtn.addEventListener('click', async ()=>{
    try{
      const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
      state.micStream = stream;
      ensureAudioGraph();
      const src = state.audioCtx.createMediaStreamSource(stream);
      connectSource(src);
      state.mode = 'mic';
      els.sourceLabel.textContent = 'Recording…';
      els.livePill.classList.remove('hidden');
      state.liveClockStart = now();
      updateDuration(0);
      if (!state.raf) loop();

      state.mediaRecorder = new MediaRecorder(stream, { mimeType: 'audio/webm' });
      state.recChunks = [];
      state.mediaRecorder.ondataavailable = (e)=>{ if(e.data && e.data.size) state.recChunks.push(e.data); };
      state.mediaRecorder.onstop = async ()=>{
        const blob = new Blob(state.recChunks, { type: 'audio/webm' });
        await buildBarsFromBlob(blob);
        const url = URL.createObjectURL(blob);
        els.audioEl.src = url; await els.audioEl.load();
        state.mode = 'file';
        els.sourceLabel.textContent = 'Recorded clip';
        els.livePill.classList.add('hidden');
        els.audioEl.onloadedmetadata = async ()=>{
          updateDuration(els.audioEl.duration||0); renderAll();
          try{ await els.audioEl.play(); if(!state.raf) loop(); }catch{}
        };
      };
      state.mediaRecorder.start();
      els.recStartBtn.disabled = true;
      els.recStopBtn.disabled = false;
    } catch(err){
      alert('Unable to access microphone: '+err);
    }
  });

  els.recStopBtn.addEventListener('click', ()=>{
    if (state.mediaRecorder && state.mediaRecorder.state !== 'inactive'){
      state.mediaRecorder.stop();
      els.recStartBtn.disabled = false;
      els.recStopBtn.disabled = true;
      if (state.micStream){ state.micStream.getTracks().forEach(t=>t.stop()); state.micStream=null; }
    }
  });

  // --- Boot
  // Fallback: if the Segment Editor tbody is missing (e.g., older local copy), inject it.
  if (!els.segTable){
    const section = document.createElement('section');
    section.className = 'bg-white rounded-2xl shadow p-4';
    section.innerHTML = `<h2 class="font-medium mb-3">Segment Editor</h2>
      <div class="overflow-x-auto"><table class="min-w-full text-sm">
      <thead><tr class="text-left text-slate-500">
        <th class="py-2 pr-4">#</th><th class="py-2 pr-4">Title</th>
        <th class="py-2 pr-4">Start (s)</th><th class="py-2 pr-4">End (s)</th>
        <th class="py-2 pr-4">State</th><th class="py-2 pr-4">Actions</th>
      </tr></thead><tbody id="segTable"></tbody></table></div>`;
    document.querySelector('.max-w-6xl')?.appendChild(section);
    els.segTable = document.getElementById('segTable');
  }

  equalize(6);
  ensureAudioGraph();
  const mctx=els.meter.getContext('2d'); mctx.fillStyle='#e2e8f0'; mctx.fillRect(0,0,els.meter.width,els.meter.height);
})();
</script>
</body>
</html>

